<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Memento模式]]></title>
    <url>%2F2021%2F01%2F29%2FMemento%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Memento模式保存对象状态类表名字说明Memento表示Gamer状态的类Gamer表示游戏主人公的类，他会生成Memento实例Main进行游戏的类。他会事先保存Memento的实例，之后会根据需要回复Gamer的状态类图代码Memento类1234567891011121314151617181920212223import java.util.ArrayList;import java.util.List;import com.sean.AbstractFactory.listfactory.ListLink;public class Memento &#123; int money; ArrayList fruits; public int getMoney()&#123; return money; &#125; Memento(int money)&#123; this.money=money; this.fruits=new ArrayList(); &#125; void addFruit(String fruit)&#123; fruits.add(fruit); &#125; List getFruits()&#123; return (List) fruits.clone(); &#125;&#125;Gamer类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.sean.Memento;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Random;public class Gamer &#123; private int money; private List fruits=new ArrayList(); private Random random=new Random(); private static String[] fruitsname=&#123;"苹果","葡萄","香蕉","橘子"&#125;; public Gamer(int money)&#123; this.money=money; &#125; public int getMoney()&#123; return money; &#125; public void bet()&#123; int dice = random.nextInt(6)+1; if(dice==1)&#123; money+=100; System.out.println("所持金币增加了。"); &#125;else if (dice==2) &#123; money/=2; System.out.println("所持金币减半。"); &#125;else if (dice==6) &#123; String f=getFruit(); System.out.println("获得的水果"+f+")。"); &#125;else&#123; System.out.println("什么都没发生。"); &#125; &#125; public Memento createMemento()&#123; Memento m=new Memento(money); Iterator it=fruits.iterator(); while(it.hasNext())&#123; String f=(String)it.next(); if(f.startsWith("好吃的"))&#123; m.addFruit(f); &#125; &#125; return m; &#125; public void restoreMemento(Memento memento)&#123; this.money=money; this.fruits=memento.getFruits(); &#125; public String toString()&#123; return "[money= "+money+",fruits= "+fruits+"]"; &#125; private String getFruit()&#123; String prefix=""; if(random.nextBoolean())&#123; prefix="好吃的"; &#125; return prefix+fruitsname[random.nextInt(fruitsname.length)]; &#125;&#125;Main123456789101112131415161718192021222324252627282930313233package com.sean.Memento;public class Main &#123; /** * @param args */ public static void main(String[] args) &#123; Gamer gamer=new Gamer(100); Memento memento=gamer.createMemento(); for(int i=0;i&lt;100;i++)&#123; System.out.println("========"+i); System.out.println("当前状态："+gamer); gamer.bet(); //进行游戏 System.out.println("所持金钱为"+gamer.getMoney()+"元"); if(gamer.getMoney()&gt;memento.getMoney())&#123; System.out.println("（所持金钱增加许多，因此保存游戏当前状态）"); memento=gamer.createMemento(); &#125;else if (gamer.getMoney()&lt;memento.getMoney()/2) &#123; System.out.println("（所持金钱减少许多，因此要恢复至以前状态）"); gamer.restoreMemento(memento); &#125; try&#123; Thread.sleep(100); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(""); &#125; &#125;&#125;个人理解该模式就是实现对象状态的恢复，而设置的。参照《图解设计模式》写这个只是为了加深自己对设计模式的理解，如不明白，可以看 《图解设计模式》。程序类图使用idea 生成的]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>Memento</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Myeclipse2017-ci9破解]]></title>
    <url>%2F2021%2F01%2F29%2FMyeclipse2017ci9%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Myeclipse2017-ci9破解 windows版安装jdk安装jdk时注意安装jdk8及以下版本，避免破解文件无法使用下载myeclipse2017ci9及破解文件下载地址密码: t77b下载完成，进行安装步骤安装myeclipse1.点击安装文件出现下图 点击next接受协议 点击next3.自己选择安装目录，一定要是空文件夹4.根据自己电脑位数选择（目前大多数电脑都是64bit）点击next5.静静的等待安装6.这一步非常重要 取消启动myeclipse 点击finish安装完成破解Myeclipse1.将破解文件patch全部内容复制到 安装目录的plugins文件夹中2.点击crack.bat 启动破解文件在Usercode任意输入 选择blue 双击 SystemId 在点击 active出现下面内容：4.点击Tools 选择 savepropertiesok!5.启动Myeclipse查看是否激活成功1.点击help — SubScription information破解完成，请勿用于商业用途。喜欢请支持正版！！！！！]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>crack</tag>
        <tag>Myeclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Observe模式]]></title>
    <url>%2F2021%2F01%2F29%2FObserve%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Observe模式在Observe模式中，当观察对象的状态发生变化，会通知给观察者。Observe模式适用于根据对象状态进行相应的处理场景。类和接口的表名字说明Observer表示观察者接口NumberGenerator表示生成数值的对象的抽象类RandomNumberGenerator生成随机数的类DigitObserver表示以数字形式显示数值类GraphObserver表示以简单的图形显示数值类Main测试程序行为的类程序类图代码Observer接口(定义抽象方法)12345package com.sean.Observer;public interface Observer &#123; public abstract void update(NumberGenerator generator);&#125;NumberGenerator抽象类1234567891011121314151617181920212223package com.sean.Observer;import java.util.ArrayList;import java.util.Iterator;public abstract class NumberGenerator &#123; private ArrayList observers = new ArrayList(); public void addObserver(Observer observer)&#123; observers.add(observer); &#125; public void deleteObserver(Observer observer)&#123; observers.remove(observer); &#125; public void notifyObservers()&#123; Iterator it=observers.iterator(); while(it.hasNext())&#123; Observer o=(Observer) it.next(); o.update(this); &#125; &#125; public abstract int getNumber(); public abstract void exeute();&#125;DigitObserver具体的观察者1234567891011121314package com.sean.Observer;public class DigitObserver implements Observer &#123; public void update(NumberGenerator generator) &#123; System.out.println("DigitObserver："+generator.getNumber()); try&#123; Thread.sleep(100); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;GraphObserver具体的观察者1234567891011121314151617181920package com.sean.Observer;public class GraphObserver implements Observer &#123; public void update(NumberGenerator generator) &#123; System.out.println("GraphObserver:"); int count = generator.getNumber(); for(int i=0;i&lt;count;i++)&#123; System.out.print("*"); &#125; System.out.println(""); try&#123; Thread.sleep(100); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;RandomNumberGenerator具体的被观察对象12345678910111213141516171819202122package com.sean.Observer;import java.util.Random;public class RandomNumberGenerator extends NumberGenerator &#123; private Random random= new Random(); private int number; @Override public int getNumber() &#123; return number; &#125; @Override public void exeute() &#123; for(int i=0;i&lt;20;i++)&#123; number=random.nextInt(50); notifyObservers(); &#125; &#125;&#125;测试方法123456789101112131415161718ackage com.sean.Observer;public class Main &#123; /** * @param args */ public static void main(String[] args) &#123; NumberGenerator generator=new RandomNumberGenerator(); Observer observer1=new DigitObserver(); Observer observer2=new GraphObserver(); generator.addObserver(observer1); generator.addObserver(observer2); generator.exeute(); &#125;&#125;要点Observer角色并非主动去观察，而是被动去观察，被动的接受观察对象的通知。参照《图解设计模式》写这个只是为了加深自己对设计模式的理解，如不明白，可以看 《图解设计模式》。程序类图使用idea 生成的]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>Observe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Proxy模式]]></title>
    <url>%2F2021%2F01%2F29%2FProxy%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Proxy模式只在必要时生成实例类表名字说明Printer表示带名字的打印机类(本人)PrintablePrinter和PrinterProxy的共同接口PrinterProxy表示带名字的打印机类(代理人)Main测试程序行为的类类图代码Printable接口12345678package com.sean.Proxy;public interface Printable &#123; public abstract void setPrinterName(String name); public abstract String getPrintName(); public abstract void print(String string);&#125;Printer12345678910111213141516171819202122232425262728293031323334353637383940package com.sean.Proxy;public class Printer implements Printable &#123; private String name; public Printer()&#123; &#125; public Printer(String name)&#123; this.name=name; heavyJob("正在生成Printer实例（"+name+")"); &#125; public void setPrinterName(String name) &#123; this.name=name; &#125; public String getPrintName() &#123; return name; &#125; public void print(String string) &#123; System.out.println("===="+name+"===="); System.out.println(string); &#125; public void heavyJob(String msg)&#123; System.out.print(msg); for(int i=0;i&lt;5;i++)&#123; try&#123; Thread.sleep(1000); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.print("."); &#125; System.out.println("结束。"); &#125;&#125;PrinterProxy123456789101112131415161718192021222324252627282930313233343536package com.sean.Proxy;public class PrinterProxy implements Printable &#123; private String name; private Printer real; public PrinterProxy()&#123; &#125; public PrinterProxy(String name)&#123; this.name=name; &#125; public synchronized void setPrinterName(String name) &#123; if(real!=null)&#123; real.setPrinterName(name); &#125; this.name=name; &#125; public String getPrintName() &#123; return name; &#125; public void print(String string) &#123; realize(); real.print(string); &#125; public synchronized void realize()&#123; if(real==null)&#123; real=new Printer(name); &#125; &#125;&#125;Main1234567891011121314151617package com.sean.Proxy;public class Main &#123; /** * @param args */ public static void main(String[] args) &#123; Printable p=new PrinterProxy("Alice"); System.out.println("现在的名字是"+p.getPrintName()+"。"); p.setPrinterName("Bob"); System.out.println("现在的名字是"+p.getPrintName()+"。"); p.print("Hello,world!"); &#125;&#125;参照《图解设计模式》写这个只是为了加深自己对设计模式的理解，如不明白，可以看 《图解设计模式》。程序类图使用idea 生成的]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Spring boot in action》笔记]]></title>
    <url>%2F2021%2F01%2F29%2FspringBootInActionNote%2F</url>
    <content type="text"><![CDATA[《spring boot in action》 读书笔记spring条件化配置这是spring4.0引入的新特性。条件化配置允许配置存在于程序中，但在满足某些特定条件之前都忽略这个配置。在spring中编写自己的条件，需要实现Condition接口，覆盖它的matches()方法自定义配置覆盖自定义配置案例：在使用 org.springframework.boot:spring-boot-starter-security 并且是使用spring-boot自动配置你每次启动web程序，都会有个身份验证，用户名为user 密码为日字里面的Using default security password: 92669112-9709-45d2-91f7-daff89accbb3我个人觉得这个比较麻烦！所以我们需要覆盖进行自定义配置。测试web应用程序要恰当地测试一个web应用程序，需要投入一些实际的HTTP请求，确认它能正确地处理那些请求。spring boot提供了两个可选的方案Spring Mock MVC : 能在一个近似真实的模拟Servlet容器里测试控制器，而不用实际启动应用服务器Web集成测试 : 在嵌入式Servlet容器（比如tomcat或Jetty）里启动应用程序，在真正的应用服务器里执行测试。两种方法各有利弊，第一种方法启动要快，而第二种方法更接近真实的生产环境。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[state模式]]></title>
    <url>%2F2021%2F01%2F29%2Fstate%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[state模式用类表示状态类图有点复杂！但只有部分是自己写的，其他是java类库内的类。粗略简单一点的类图代码State123456789package com.sean.State;public interface State &#123; public abstract void doClock(Context context,int hour); public abstract void doUse(Context context); public abstract void doAlarm(Context context); public abstract void doPhone(Context context);&#125;NightState(具体的状态)123456789101112131415161718192021222324252627282930313233343536package com.sean.State;public class NightState implements State &#123; private static NightState singleton = new NightState(); private NightState()&#123; &#125; public static State getInstance()&#123; return singleton; &#125; public void doClock(Context context, int hour) &#123; if(9&lt;=hour || hour&lt;17)&#123; context.changeState(DayState.getInstance()); &#125; &#125; public void doUse(Context context) &#123; context.callSecurityCenter("紧急！晚上使用金库！"); &#125; public void doAlarm(Context context) &#123; context.callSecurityCenter("按下警铃（晚上）"); &#125; public void doPhone(Context context) &#123; context.callSecurityCenter("晚上通话录音"); &#125; public String toString()&#123; return "[晚上]"; &#125;&#125;DayState(具体的状态)123456789101112131415161718192021222324252627282930313233343536package com.sean.State;public class DayState implements State &#123; private static DayState singleton = new DayState(); private DayState()&#123; &#125; public static State getInstance()&#123; return singleton; &#125; public void doClock(Context context, int hour) &#123; if(hour&lt;9 || 17&lt;=hour)&#123; context.changeState(NightState.getInstance()); &#125; &#125; public void doUse(Context context) &#123; context.recordLog("使用金库（白天）"); &#125; public void doAlarm(Context context) &#123; context.callSecurityCenter("按下警铃（白天）"); &#125; public void doPhone(Context context) &#123; context.callSecurityCenter("正常通话（白天）"); &#125; public String toString()&#123; return "[白天]"; &#125;&#125;Context12345678package com.sean.State;public interface Context &#123; public abstract void setClock(int hour); public abstract State changeState(State state); public abstract void callSecurityCenter(String msg); public abstract void recordLog(String msg);&#125;SafeFrame12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.sean.State;import java.awt.BorderLayout;import java.awt.Button;import java.awt.Color;import java.awt.Frame;import java.awt.Panel;import java.awt.TextArea;import java.awt.TextField;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class SafeFrame extends Frame implements ActionListener, Context &#123; private TextField textClock = new TextField(60); private TextArea textScreen=new TextArea(10,60); private Button buttonUse=new Button("使用金库"); private Button buttonAlarm=new Button("按下警铃"); private Button buttonPhone=new Button("正常通话"); private Button buttonExit=new Button("结束"); private State state=DayState.getInstance(); //构造函数 public SafeFrame(String title)&#123; super(title); setBackground(Color.lightGray); setLayout(new BorderLayout()); //配置textClock add(textClock,BorderLayout.NORTH); textClock.setEditable(false); //配置textScreen add(textScreen,BorderLayout.CENTER); textScreen.setEditable(false); //为界面添加按钮 Panel panel=new Panel(); panel.add(buttonUse); panel.add(buttonAlarm); panel.add(buttonPhone); panel.add(buttonExit); //配置界面 add(panel,BorderLayout.SOUTH); //显示 pack(); show(); //设置监听器 buttonUse.addActionListener(this); buttonAlarm.addActionListener(this); buttonPhone.addActionListener(this); buttonExit.addActionListener(this); &#125; public void setClock(int hour) &#123; String clockstring="现在时间是:"; if(hour&lt;10)&#123; clockstring+="0"+hour+":00"; &#125;else &#123; clockstring+=hour+":00"; &#125; System.out.println(clockstring); textClock.setText(clockstring); state.doClock(this, hour); &#125; public State changeState(State state) &#123; System.out.println("从"+this.state+"状态变为了"+state+"状态"); this.state=state; return state; &#125; public void callSecurityCenter(String msg) &#123; textScreen.append("Call!"+msg+"\n"); &#125; public void recordLog(String msg) &#123; textScreen.append("record ... "+msg+"\n"); &#125; public void actionPerformed(ActionEvent e) &#123; System.out.println(e.toString()); if(e.getSource()==buttonUse)&#123; state.doUse(this); &#125;else if (e.getSource()==buttonAlarm) &#123; state.doAlarm(this); &#125;else if (e.getSource()==buttonPhone) &#123; state.doPhone(this); &#125;else if (e.getSource()== buttonExit) &#123; System.exit(0); &#125;else &#123; System.out.println("?"); &#125; &#125;&#125;Main1234567891011121314151617181920212223package com.sean.State;public class Main &#123; /** * @param args */ public static void main(String[] args) &#123; SafeFrame frame=new SafeFrame("state module"); while(true)&#123; for(int hour=0;hour&lt;24;hour++)&#123; frame.setClock(hour); //设置时间 try&#123; Thread.sleep(1000); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;要点采用分而治之方针。定义接口，声明抽象方法定义多个类，实现具体的方法参照《图解设计模式》写这个只是为了加深自己对设计模式的理解，如不明白，可以看 《图解设计模式》。程序类图使用idea 生成的]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>state</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建hexo和github遇到问题]]></title>
    <url>%2F2021%2F01%2F29%2F%E6%90%AD%E5%BB%BAhexo%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[搭建hexo和github遇到问题学习一样新事物，总是要经历磕磕碰碰，才能有所成长！脚踏实地，一步一个脚印，走好每一步，不要给自己留遗憾！安装hexo问题安装hexo我是在网上找教程安装的：1.安装node.js(去官网下载windows版的安装包) node.js官网2.安装git git下载地址3.申请github账号 github 这里自己注册设置user.name user.email12$ git config --global user.name "你的GitHub用户名"$ git config --global user.email "你的GitHub注册邮箱"4.生成ssh密匙输入123456789101112131415161718192021222324$ ssh-keygen -t rsa -C "你的GitHub注册邮箱"``` 一路回车就OK了！此时，在用户文件夹下就会有一个新的文件夹.ssh，里面有刚刚创建的ssh密钥文件id_rsa和id_rsa.pub。上传公匙添加到github上 ***记住是id_rsa.pub内容复制到github上***5.安装hexo ``` bash$ npm install hexo-cli g# 建立一个文件夹hexo$ mkdir hexo # 初始化hexo文件夹$ hexo init hexo# 安装hexo插件(都安装吧!)$ npm install hexo-server --save$ npm install hexo-admin --save$ npm install hexo-generator-archive --save$ npm install hexo-generator-feed --save$ npm install hexo-generator-search --save$ npm install hexo-generator-tag --save$ npm install hexo-deployer-git --save$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-category --save6.本地使用hexo1234# 生成静态页面$ hexo generate# 开启本地服务器(可以使用全名 hexo server)$ hexo s在浏览器输入 http://localhost:4000/ 就可以在本地访问blog7.hexo部署到github上先在github上创建一个仓库 名字： github用户名.github.io这个创库的命名规则不能弄错了！！！！！！修改博客配置文件(hexo/_config.yml)，在文件里找到下面内容并修改123456789# Deployment 注释## Docs: https://hexo.io/docs/deployment.htmldeploy: # 类型 type: git # 仓库 repo: git@github.com:用户名/用户名.github.io.git # 分支 branch: master记得一定要修改成自己的用户名！！！！ 这种方式使用ssh链接(前提是你添加了公钥到github)还有一种方式是把repo 修改为下面1repo: https://github.com/用户名/用户名.github.io由于我用得两个github账号，建立hexo博客是换了一个新的账号 使用这种方式总是报 403 错误 我是改用ssh链接github输入下面的命令将hexo博客部署到github中：123456# 清空静态页面hexo clean# 生成静态页面hexo generate# 部署 hexo deploy这里有一点建议：发布时最好连续执行这三个命令，以免部署到github的hexo为以前的，就相当于刷新一下缓存。hexo替换主题我使用的next主题1.打开git bash 并切换到你的博客目录下 比如我的博客目录是 /hexo1234#自己切换自己的博客目录$ cd hexo# 执行下面命令$ git clone https://github.com/iissnan/hexo-theme-next themes/next2.修改博客配置文件 /hexo/_config.yml 如下：12345# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/#以前的选项为 theme: landscapetheme: next3.修改主题配置文件 /hexo/themes/next/_config.ymlmenu修改找到下面内容123456789101112# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------menu: home: / || home #about: /about/ || user tags: /tags/ || tags #categories: /categories/ || th #archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat去掉 # 就可以多一个菜单栏 比如去掉123456789menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th #archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat虽然在首页能看见这个菜单，但是是不能使用点击菜单 categories 会返回 can’t get /categories/ 错误信息首先要安装categories对应插件1$ npm install hexo-generator-category --save再在gitbash输入（hexo目录下）1$ hexo new page categories在/hexo/source 目录下发现多的一个categories文件夹 进入 编辑 index.md123456---title: categoriesdate: 2018-1-22 12:39:04type: &quot;categories&quot;comments: false---在/hexo/source/_post 目录建立 test.md 内容如下12345---title: testcategories: - Testing---注意空格！！！！注意空格！！！！注意空格！！！！注意空格！！！！赞赏功能问题在添加赞赏功能是替换了图片不能出现赞赏功能next赞赏功能启用在主题配置文件 找到如下内容 并修改如下：1234567891011121314# Rewardreward_comment: Donatewechatpay: /images/wechatpay.pngalipay: /images/alipay.jpg#bitcoin: /images/bitcoin.png``` 自己图片位置在 Hexo/themes/next/source image文件内修改成这样过后但是还是不能显示赞赏功能。至少我是这样，经过百度终于解决了。在主题配置文件查找# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150修改如下:12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150在执行1$ hexo clean &amp;&amp; hexo generate &amp;&amp; hexo s这下应该可以！本地搜索配置1.hexo配置文件(/hexo/_config.yml)添加123456#searchsearch: path: search.xml field: post format: html limit: 100002.安装插件12$ npm install hexo-generator-search --save$ npm install hexo-generator-searchdb --save3.修改 主题配置文件(/hexo/themes/next/_config.yml)123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: false # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1修改为123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1集成gitment评论问题自己按照网上教程安装的几次，但出现的问题是 “未开发评论” 点击login出现404错误经过一天的努力终于知道原因的，需要发布到git上去，再用自己的git账号登录一下就OK了！由于没有清除浏览器缓存，出现发布了但未更新。评论还是以前那样。记得清除浏览器缓存，或者换一个浏览器。集成步骤：1.注册OAuth Application 点击 https://github.com/settings/applications/new2.修改 themes/next/_config.yml12345678910111213141516171819202122# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/# You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;gitment: enable: true mint: false # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # 需要懒加载的 修改为true # Comments lazy loading with a button cleanly: true # Hide &apos;Powered by ...&apos; on footer, and more language: # Force language, or auto switch by theme github_user: 你的github用户名 github_repo: 用户名.github.io client_id: 创建OAuth Application时用户id client_secret: 填写你自己的client_secret #proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect #redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled其他的就不用修改了。默认就OK了！等以后玩熟了再自定义配置！参考文档next参考文档hexo参考文档没事就多看看官方文档，应该能解决问题的！加油！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过vpn登录学校内网]]></title>
    <url>%2F2021%2F01%2F29%2F%E5%AD%A6%E6%A0%A1vpn%2F</url>
    <content type="text"><![CDATA[在家使用vpn访问学校内网(教务系统，图书馆等)要求1.一台能上网的电脑2.windows系统3.系统安装了IE首先登录学校官网点击下面大连海事大学点击vpn进入界面是这样，请点击 详细信息然后是这样的界面点击 继续转到网页出现如果是第一次使用此软件请点击下载Easy Connect下载完成后记得安装图如下安装完成记得重启电脑。电脑桌面上应该多了两个快捷方式开始使用回到这个界面，请点击 运行Easy Connect选择 是第一次使用会自动安装组件最后出现用户名是学号密码是登录教务系统密码登录成功如下即可访问学校内网!]]></content>
      <categories>
        <category>school</category>
      </categories>
      <tags>
        <tag>problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TemplateMethod模式]]></title>
    <url>%2F2021%2F01%2F29%2FTemplateMethod%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[TemplateMethod模式将具体处理交给子类带有模板功能的模式。在父类中定义处理流程的框架，在子类中实现具体处理的模式就称为TemplateMethod模式。在抽象类阶段确定处理的流程非常重要。类图代码AbstractDisplay1234567891011121314151617181920package com.sean.TemplateMethod;/** * 抽象类中可有具体的方法实现 * 但是如果用接口是不行的（原因：接口不能有具体的方法实现） * @author sean * */public abstract class AbstractDisplay &#123; //修改修饰符可以改变抽象类方法的访问权限问题 public abstract void open(); public abstract void print(); public abstract void close(); public final void display()&#123; open(); for(int i=0;i&lt;5;i++)&#123; print(); &#125; close(); &#125;&#125;CharDisplay1234567891011121314151617181920212223242526package com.sean.TemplateMethod;public class CharDisplay extends AbstractDisplay &#123; private char ch; public CharDisplay(char ch)&#123; this.ch=ch; &#125; @Override public void open() &#123; System.out.print("&lt;&lt;"); &#125; @Override public void print() &#123; System.out.print(ch); &#125; @Override public void close() &#123; System.out.println("&gt;&gt;"); &#125;&#125;StringDisplay12345678910111213141516171819202122232425262728293031323334package com.sean.TemplateMethod;public class StringDisplay extends AbstractDisplay &#123; private String string; private int width; public StringDisplay(String string)&#123; this.string=string; this.width=string.getBytes().length; &#125; @Override public void open() &#123; printLine(); &#125; @Override public void print() &#123; System.out.println("|"+string+"|"); &#125; @Override public void close() &#123; printLine(); &#125; private void printLine()&#123; System.out.print("+"); for(int i=0;i&lt;width;i++)&#123; System.out.print("-"); &#125; System.out.println("+"); &#125;&#125;Main123456789101112package com.sean.TemplateMethod;public class Main &#123; public static void main(String[] args) &#123; AbstractDisplay d1=new CharDisplay('H'); AbstractDisplay d2=new StringDisplay("Hello,world"); d1.display(); d2.display(); &#125;&#125;要点Template Method模式中，父类与子类是紧密联系，共同工作的。在子类中实现父类的抽象方法。参照《图解设计模式》写这个只是为了加深自己对设计模式的理解，如不明白，可以看 《图解设计模式》。程序类图使用idea 生成的]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>TemplateMethod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mediator模式]]></title>
    <url>%2F2021%2F01%2F29%2FMediator%2F</url>
    <content type="text"><![CDATA[Mediator模式只有一个仲裁者&ensp; 要调用多个对象之间的关系时，就需要使用Mediator模式。将控制的逻辑处理交给仲裁者。类和接口表名字说明Mediator定义 “仲裁者” 的接口(API)的接口Colleague定义”组员”的接口(API)的接口ColleagueButton表示按钮的类。它实现Colleague接口ColleagueTextField表示文本输入框的类。它实现了Colleague接口ColleagueCheckbox表示勾选框的类。实现了Colleague接口LoginFrame表示登录对话框类。实现了Mediator接口Main测试程序行为的类程序的类图有点复杂喔！ 不急。慢慢看！！代码Colleague接口(组员接口)1234567package com.sean.Mediator;public interface Colleague &#123; public abstract void setMediator(Mediator mediator); public abstract void setColleagueEnabled(boolean enabled);&#125;Mediator接口(仲裁者接口)12345678package com.sean.Mediator;public interface Mediator &#123; //生成Mediator要管理的组员. public abstract void createColleagues(); //被各个Colleague组员调用，让组员向仲裁者进行报告 public abstract void colleagueChanged();&#125;ColleagueButton(具体的组员)123456789101112131415161718192021import java.awt.Button;import java.awt.HeadlessException;public class ColleagueButton extends Button implements Colleague &#123; private Mediator mediator; public ColleagueButton(String caption) &#123; super(caption); &#125; public void setMediator(Mediator mediator) &#123; //保存Mediator this.mediator=mediator; &#125; public void setColleagueEnabled(boolean enabled) &#123; //Mediator下达启用禁用的指示 setEnabled(enabled); &#125;&#125;ColleagueCheckbox(具体的组员)1234567891011121314151617181920212223242526272829package com.sean.Mediator;import java.awt.Checkbox;import java.awt.CheckboxGroup;import java.awt.event.ItemEvent;import java.awt.event.ItemListener;public class ColleagueCheckbox extends Checkbox implements Colleague, ItemListener &#123; private Mediator mediator; public ColleagueCheckbox(String caption,CheckboxGroup group,boolean state)&#123; super(caption,group,state); &#125; public void itemStateChanged(ItemEvent e) &#123; mediator.colleagueChanged(); &#125; public void setMediator(Mediator mediator) &#123; this.mediator=mediator; &#125; public void setColleagueEnabled(boolean enabled) &#123; setEnabled(enabled); &#125;&#125;ColleagueTextField(具体的组员)1234567891011121314151617181920212223242526272829import java.awt.Color;import java.awt.TextField;import java.awt.event.TextEvent;import java.awt.event.TextListener;public class ColleagueTextField extends TextField implements Colleague, TextListener &#123; private Mediator mediator; public ColleagueTextField(String text,int columns)&#123; super(text,columns); &#125; public void textValueChanged(TextEvent e) &#123; //文字发生变化时通知Mediator mediator.colleagueChanged(); &#125; public void setMediator(Mediator mediator) &#123; this.mediator=mediator; &#125; public void setColleagueEnabled(boolean enabled) &#123; setEnabled(enabled); setBackground(enabled ? Color.white : Color.lightGray); &#125;&#125;LoginFrame(具体的仲裁者)代码有点多加油看看！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.sean.Mediator;import java.awt.CheckboxGroup;import java.awt.Color;import java.awt.Frame;import java.awt.GridLayout;import java.awt.Label;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class LoginFrame extends Frame implements ActionListener, Mediator &#123; private ColleagueCheckbox checkGuest; private ColleagueCheckbox checkLogin; private ColleagueTextField textUser; private ColleagueTextField textPass; private ColleagueButton buttonOK; private ColleagueButton buttonCancle; //构造函数 //生成并配置各个Colleague后，显示对话框 public LoginFrame(String title)&#123; super(title); setBackground(Color.lightGray); //使用布局管理器生成4×2窗格 setLayout(new GridLayout(4,2)); //生成各个Colleague createColleagues(); add(checkGuest); add(checkLogin); add(new Label("username")); add(textUser); add(new Label("Password")); add(textPass); add(buttonOK); add(buttonCancle); //设置初始的启用/禁用状态 colleagueChanged(); //显示 pack(); show(); &#125; public void createColleagues() &#123; //生成各个Colleague CheckboxGroup g= new CheckboxGroup(); checkGuest = new ColleagueCheckbox("Guest",g,true); checkLogin = new ColleagueCheckbox("Login",g,false); textUser = new ColleagueTextField("",10); textPass = new ColleagueTextField("",10); textPass.setEchoChar('*'); buttonOK = new ColleagueButton("OK"); buttonCancle = new ColleagueButton("Cancle"); //设置Mediator checkGuest.setMediator(this); checkLogin.setMediator(this); textUser.setMediator(this); textPass.setMediator(this); buttonOK.setMediator(this); buttonCancle.setMediator(this); //设置Listener checkGuest.addItemListener(checkGuest); checkLogin.addItemListener(checkLogin); textUser.addTextListener(textUser); textPass.addTextListener(textPass); buttonOK.addActionListener(this); buttonCancle.addActionListener(this); &#125; public void colleagueChanged() &#123; if(checkGuest.getState())&#123; textUser.setColleagueEnabled(false); textPass.setColleagueEnabled(false); buttonOK.setColleagueEnabled(true); &#125;else &#123; textUser.setColleagueEnabled(true); userpassChanged(); &#125; &#125; public void userpassChanged()&#123; if(textUser.getText().length()&gt;0)&#123; textPass.setColleagueEnabled(true); if(textPass.getText().length()&gt;0)&#123; buttonOK.setColleagueEnabled(true); &#125;else&#123; buttonOK.setColleagueEnabled(false); &#125; &#125;else &#123; textPass.setColleagueEnabled(false); buttonOK.setColleagueEnabled(false); &#125; &#125; public void actionPerformed(ActionEvent e) &#123; System.out.println(e.toString()); System.exit(0); &#125;&#125;主函数 调用者 客户代码比较少！放松！放松！放松！12345678910111213package com.sean.Mediator;public class Main &#123; /** * @param args */ public static void main(String[] args) &#123; LoginFrame lf=new LoginFrame("Mediator Sample"); &#125;&#125;个人理解Mediator模式就如同在一个集体中需要一个管理者，没管理者就是一团乱麻！有管理者，能让程序有序的进行！虽然我们崇尚自由！但是没有管理的世界更可怕！生活中需要管理者，程序中也需要管理者！程序来源于生活。参照图解设计模式写这个只是为了加深自己对设计模式的理解，如不明白，可以看 《图解设计模式》。程序类图使用idea 生成的]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>Mediator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux简单介绍]]></title>
    <url>%2F2021%2F01%2F29%2Flinux%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[linuxLinux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。Linux操作系统诞生于1991 年10 月5 日（这是第一次正式向外公布时间）。Linux存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。linux简介linux的核心是由Linus Torvads 在1991年的时候开发出来的。讲linux的必须先讲它的大哥UnixUnix是以高阶的C语言在贝尔实验室(AT&amp;T)写成的。总之Unix是一个很6的系统,可以查阅Unix的源代码。刚开发时，大家都可以免费使用。后来由于AT&amp;T由于商业的考虑，于是将Unix的版权回收。特别提到 不可对学生提供源代码。版权的收回，影响到学校教Unix源代码的教授！Andrew Tanenbaum(谭宁邦)教授自己动手写了Minix这个Unix Like的核心代码！在编写源代码过程中，为了避免版权纷争，教授完全不看Unix核心源代码！并且强调Minix要完全和Unix兼容才行！1984开始写代码，到1986年结束。1984年的GNU计划。（Richard Mathew Stallman 史托曼）软件分享GCC(GNU C Complier )后来就是Linus Torvads 在Minix的基础上编写了linux。于1991年发布。大概就讲这么多吧！linux 发行版本自己看图吧！如果看的不清楚可以去这个网站 linux发行图linux发行图是不是太多了！看的都眼花了！自己选择一款喜欢的发行版本。友情链接Redhat Centos Debian ubuntu SUSE openSUE自己可以玩玩！当然还有很多其他版本！也有一些酷炫的版本！linux安装我们安装Ubuntu版的linux系统。安装桌面版的。易于个人使用。首先去官网下载ubuntu镜像Ubuntu下载地址Ubuntu安装教程提醒要点1.要使用刻录盘刻录镜像。刻录完镜像，就可以像安装win10系统一样安装，当然需要修改bios.记得自己分一个干净的盘来安装linux系统。2.安装要注意分区表格式。3.系统只能安装在主分区不能安装在逻辑分区。linux简单的使用linux不同版本的linux命令有一些不同的地方，但是大部分是相同的。下面是Ubuntu系统使用的命令。希望你们在学习linux时多敲命令！如同windows上的cmd常见命令使用打开终端鼠标右击 -&gt; 选择 Open Terminal如下图首先讲一个特别有用的命令 man这个命令是挺厉害的！比如想知道 ls命令怎么用？可以使用1man ls最后回车键 Enter键 执行命令按回车或移动鼠标，可以看ls的帮助文档。不需要阅读帮助文档，看上面截屏的提示。按 q 建退出帮助文档当然还有一种查看帮助文档的命令: command --help1ls --help记住命令之间一定要有空格！大小写也很重要！关机命令1poweroff重启命令1reboot切换目录的命令1cd /home/sean/Pictures输入 ls如果输入 ls -la 就会显示更多信息top命令就如同windows上的资源管理器1topctr + z停止这个命令安装软件各个linux发行版本的安装软件的方法不一样。ubuntu有一个安装软件的app.看图看见了VLC视屏播放软件了。这个也挺好用的。上学期我讲过。用软件安装软件是挺方便的，但是这个软件库的版本就太老了。还有安装软件的方法，就是使用命令行。sudo apt-get install softname例如安装 vim 文本编辑软件。挺好用的。Ubuntu不自带vim,需要额外安装。Centos自带vim1sudo apt-get install vim会叫你输入密码：你输入时不会显示 ****,输入完成回车，OK！我的是已经安装了。你们安装时一路回车就安装了。vim简单使用1vim vim.txt回车按 a,就可以写文本了。再按 ESC键输入 :wq就OK了。Ubuntu 是用apt-get 命令而Centos使用yum安装源代码安装还有一种安装软件的方法就是源代码编译安装。使用 make命令。这里我就不多说了。应为这涉及库的问题。该方法能安装新版的软件，但是也是最难使用的，不是因为命令复杂，而是因为不容易安装所需要的库！安装搜狗输入法搜狗输入法下载linux安装教程自己看博客当然Ubuntu17.10就自带有中文输入法！(我依稀记得是这样！)]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab函数类型]]></title>
    <url>%2F2021%2F01%2F29%2Fmatlab%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[matlab 函数类型主函数主函数在结构上与其他函数没有什么区别，之所以叫主函数，就是因为他在M文件中坐了第一把交椅，其他函数都排在他的后面。按惯例他与M文件同名，在命令窗口或者其他函数中调用这个函数，都是引用M文件名。子函数主函数之后编写的函数为子函数。在函数M文件中,只有一个主函数，但是可以有多个子函数。所有的子函数也采用function进行定义。如果主函数中包含子函数，则每个采用function定义的函数必须采用end结束。各个子函数的先后顺序和调用的先后顺序无关。在主函数进行函数调用时，首先查找该函数文件中的子函数，如果有同名的子函数，则调用该子函数。因此，可以编写同名的子函数实现函数的重载。子函数只能被同一文件的主函数或其他子函数调用。嵌套函数在函数内部，还可以定义一个或者多个函数称为函数的嵌套。在函数的内部定义的函数称为嵌套函数。可以进行多层嵌套。每个用function定义的函数都必须用end语句结束。嵌套函数也有自己的工作区。注意变量作用范围。私有函数私有函数要保存在该目录的private文件夹下,具有有限的访问权限。私有函数的编写和普通函数的编写没有什么区别。函数M文件可以直接调用私有函数。该函数M文件所在的目录下直接有一个private目录，私有函数就保存在该目录下。私有函数只能被其父目录内的脚本或函数调用。重载函数在MATLAB中有很多都是重载函数，重载函数具有相同的函数名，但是参数类型或个数不同。当用户在调用函数时，MATLAB会根据实际参数类型和个数来选择其中一个。在MATLAB中重载函数保存在不同的目录下。匿名函数匿名函数通常是很简单的函数。匿名函数是面向命令行的函数形式，它通常只有一句很简单的声明语句组成。创建匿名函数的标准格式fhandle=@(arglist) expression其中，expression通常为一个简单的MATLAB变量表达式实现函数功能。arglist 为此匿名函数的输入参数列表。内联函数内联函数是MATLAB比较简单的函数之一。其适用于表达式较为简单的函数。调用格式：funName=inline(expr)funName为所定义的内联函数名称expr为表达式对应的字符串。函数句柄函数句柄是一种特殊的函数类型，它提供了间接调用函数的方法，类似于C语言中的指针，只是这里只指向函数。函数句柄包含了该函数的函数名和类型等信息，可以通过函数 functions()来获取信息。创建函数句柄使用 @ ，可以使用函数句柄调用其他函数，也可以将函数句柄存储在数据结构中，方便以后使用。当使用函数句柄调用函数时，MATLAB会立即执行，不会进行文件收缩。当多次调用一个函数文件时，可以节约大量的搜索时间，从而提高函数的执行效率。]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP自定义标签]]></title>
    <url>%2F2021%2F01%2F29%2FJSP%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[JSP自定义标签自定义标签的实现，叫做标签处理器，而简单的标签处理器是指继承SimpleTag 实现的标签管理器。简单标签管理器不在被jsp容器缓存。但这并不意味着简单标签处理器会比之前的慢。初始化性能指标显示，缓存标签处理器并不能提供较好的性能优化，但缓存这些标签让实现标签变得更加困难，而且让这些标签带来更多的潜在错误。JSP规范的作者在JSP规范的7.15一节写到SimpleTag接口中用于标签触发的方法只有一个doTag，并且该方法只会执行一次。业务逻辑，遍历以及页面内容的操作都在这里实现。javax.servlet.jsp.targext包中包含了一个SimpleTag的基础类SimpleTagSupport提供了SimpleTag的所有方法的实现，并便于扩展简单标签处理器。SimpleTagSupport类中用getJspContext方法返回JspContext实例，这个实例在JSP容器中用SimpleTag的setJspContext方法传入。SimpleTag示例编写标签处理器MyFirstTag类1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.sean;import java.io.IOException;import javax.servlet.jsp.JspContext;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.JspFragment;import javax.servlet.jsp.tagext.JspTag;import javax.servlet.jsp.tagext.SimpleTag;public class MyFirstTag implements SimpleTag&#123; JspContext jspContext; @Override public void doTag() throws JspException, IOException &#123; System.out.println("doTag"); jspContext.getOut().print("This is my first tag."); &#125; @Override public JspTag getParent() &#123; System.out.println("getParent"); return null; &#125; @Override public void setJspBody(JspFragment body) &#123; System.out.println("setJspBody"); &#125; @Override public void setJspContext(JspContext jspContext) &#123; System.out.println("setJspContext"); this.jspContext=jspContext; &#125; @Override public void setParent(JspTag parent) &#123; System.out.println("setParent"); &#125;&#125;注册标签mytags.tld1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;taglib xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee web-jsptaglibrary_2_1.xsd" version="2.1"&gt; &lt;description&gt; Simple tag examples &lt;/description&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;My First Taglib Example&lt;/short-name&gt; &lt;tag&gt; &lt;name&gt;firstTag&lt;/name&gt; &lt;tag-class&gt;com.sean.MyFirstTag&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt; &lt;/taglib&gt;name节点用于说明这个标签名称；tag-class则用于指出标签处理器的完整类名。当然一个标签库中可以定义多个标签。使用标签1234567891011121314151617&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="/WEB-INF/mytags.tld" prefix="easy" %&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;firstTagTest&lt;/title&gt; &lt;body&gt; Hello! &lt;br&gt; &lt;easy:firstTag&gt;&lt;/easy:firstTag&gt; &lt;/body&gt;&lt;/html&gt;我的项目名 customtag启动服务器，输入即可。http://localhost:8080/customtag/firstTagTest.jsp处理属性实现SimpleTag接口或者扩展SimpleTagSupport的标签管理器都可以有属性。DataFrmatterTag继承SimpleTagSupport1234567891011121314151617181920212223242526272829303132333435363738394041package com.sean;import java.io.IOException;import java.util.StringTokenizer;import javax.servlet.jsp.JspContext;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.tagext.SimpleTagSupport;public class DataFrmatterTag extends SimpleTagSupport &#123; private String header; private String items; public String getHeader() &#123; return header; &#125; public void setHeader(String header) &#123; this.header = header; &#125; public String getItems() &#123; return items; &#125; public void setItems(String items) &#123; this.items = items; &#125; public void doTag() throws IOException,JspException&#123; JspContext jspContext=getJspContext(); JspWriter out=jspContext.getOut(); out.print("&lt;table style='border:1px solid green'&gt;\n" +"&lt;tr&gt;&lt;td&gt;&lt;span style='font-weight:bold'&gt;" +header+"&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;\n"); StringTokenizer tokenizer=new StringTokenizer(items,","); while(tokenizer.hasMoreTokens())&#123; String token=tokenizer.nextToken(); out.print("&lt;tr&gt;&lt;td&gt;"+token+"&lt;/td&gt;&lt;/tr&gt;\n"); &#125; out.print("&lt;/table&gt;"); &#125; &#125;doTag() 首先通过getJspContext()获取通过JSP容器传入的 JspContext对象JspContext jspContext=getJspContext();接着，通过JspContext实例的getOut()获取JspWriter对象JspWriter out=jspContext.getOut();然后，doTag()方法使用StringTokenizer解析items属性值。###注册DataFrmatter标签1234567891011121314&lt;tag&gt;&lt;name&gt;dataFormatter&lt;/name&gt;&lt;tag-class&gt;com.sean.DataFrmatterTag&lt;/tag-class&gt;&lt;body-content&gt;empty&lt;/body-content&gt;&lt;attribute&gt; &lt;name&gt;header&lt;/name&gt; &lt;required&gt;true&lt;/required&gt;&lt;/attribute&gt;&lt;attribute&gt; &lt;name&gt;items&lt;/name&gt; &lt;required&gt;true&lt;/required&gt;&lt;/attribute&gt;&lt;/tag&gt;dataFormatterTagTest.jsp12345678910111213141516171819202122232425&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="/WEB-INF/mytags.tld" prefix="easy" %&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;My JSP 'dataFormatterTagTest.jsp' starting page&lt;/title&gt; &lt;title&gt;Testing DataFormatterTag&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;easy:dataFormatter items="Alabama,Alaska,Georgia,Florida" header="states"/&gt; &lt;br&gt; &lt;easy:dataFormatter header="Countries"&gt; &lt;jsp:attribute name="items"&gt; US,UK,Canada,Korea &lt;/jsp:attribute&gt; &lt;/easy:dataFormatter&gt; &lt;/body&gt;&lt;/html&gt;访问标签内容SelectElementTag类1234567891011121314151617181920212223package com.sean;import java.io.IOException;import javax.servlet.jsp.JspContext;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.tagext.SimpleTagSupport;public class SelectElementTag extends SimpleTagSupport &#123; private String[] countries =&#123;"China","Brazil","American","Japan"&#125;; public void doTag() throws IOException,JspException&#123; JspContext jspContext=getJspContext(); JspWriter out=jspContext.getOut(); out.print("&lt;select&gt;\n"); for(int i=0;i&lt;countries.length;i++)&#123; getJspContext().setAttribute("value", countries[i]); getJspContext().setAttribute("text", countries[i]); getJspBody().invoke(null); &#125; out.print("&lt;/select&gt;\n"); &#125;&#125;注册selectElementTag12345 &lt;tag&gt; &lt;name&gt;select&lt;/name&gt; &lt;tag-class&gt;com.sean.SelectElementTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt;&lt;/tag&gt;selectElementTagTest.jsp1234567891011121314151617181920&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="/WEB-INF/mytags.tld" prefix="easy" %&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;My JSP 'selectElementTagTest.jsp' starting page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;easy:select&gt; &lt;option value="$&#123;value&#125;"&gt;$&#123;text&#125;&lt;/option&gt; &lt;/easy:select&gt; &lt;/body&gt;&lt;/html&gt;我的项目名 customtag启动服务器，输入即可。http://localhost:8080/customtag/selectElementTagTest.jsp编写EL函数编写EL函数步骤1.创建一个包含静态方法的public类。每个类的静态方法表示一个EL函数。这个类可以不需要实现任何借口或者继承特定的类。可以像发布其他任何类一样发布这个类2.用function节点在标签库描述器注册函数节点说明description可选，标签说明display-name在xml工具中显示缩写名字icon可选，在xml工具中使用icon节点name函数的唯一名字function-class该函数对应实现的java类的全名function-signature该函数对应实现的java静态方法example可选，使用该函数的实例说明function-extension可以是一个或者多个节点 ，在xml工具中使用，用于提供该函数更多细节使用该函数，须将taglib指令中的uri属性指向标签库描述，并指明使用的前缀。然后在JSP页面使用如下语法：${prefix:functionName(parameterList)}MyFunction12345678package com.sean.function;public class MyFunction &#123; public static String reverseString(String s)&#123; //字符串的反转 return new StringBuffer(s).reverse().toString(); &#125;&#125;functiontags.tld123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;taglib xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee web-jsptaglibrary_2_1.xsd" version="2.1"&gt; &lt;description&gt;Function tag example&lt;/description&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;uri&gt;http://example.com/taglib/function&lt;/uri&gt; &lt;function&gt; &lt;description&gt;Reverse a String&lt;/description&gt; &lt;name&gt;reverseString&lt;/name&gt; &lt;function-class&gt;com.sean.function.MyFunction&lt;/function-class&gt; &lt;function-signature&gt;java.lang.String reverseString(java.lang.String)&lt;/function-signature&gt; &lt;/function&gt;&lt;/taglib&gt;使用El12345678910111213141516171819&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://example.com/taglib/function" prefix="f" %&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;My JSP 'functionTagTest.jsp' starting page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; $&#123;f:reverseString("Hello, World") &#125; &lt;br&gt; $&#123;f:reverseString("Welcome")&#125; &lt;/body&gt;&lt;/html&gt;发布自定义标签在functiontags.tld增加uri节点&lt;uri&gt;http://example.com/taglib/function&lt;/uri&gt;在jsp页面添加&lt;%@ taglib uri=&quot;http://example.com/taglib/function&quot; prefix=&quot;f&quot; %&gt;总结自定义标签解决JavaBean中前端展现与后端逻辑分离的好办法。]]></content>
      <categories>
        <category>Java</category>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FactoryMethod模式]]></title>
    <url>%2F2021%2F01%2F29%2FFactoryMethod%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[FactoryMethod模式将实例的生成交给子类用TemplateMethod模式来构建生成的实例的工厂，就是FactoryMethod模式。类图codeFactory123456789101112package com.sean.FactoryMethod.framework;public abstract class Factory &#123; public final Product create(String owner)&#123; Product product=createProduct(owner); registerProduct(product); return product; &#125; protected abstract Product createProduct(String owner); protected abstract void registerProduct(Product product); &#125;Product123456package com.sean.FactoryMethod.framework;public abstract class Product &#123; public abstract void use();&#125;IDCard1234567891011121314151617181920package com.sean.FactoryMethod.idcard;import com.sean.FactoryMethod.framework.Product;public class IDCard extends Product &#123; private String owner; IDCard(String owner)&#123; System.out.println("制作"+owner+"的ID卡。"); this.owner=owner; &#125; @Override public void use() &#123; System.out.println("使用"+owner+"的ID卡。"); &#125; public String getOwner()&#123; return owner; &#125;&#125;IDCardFactory12345678910111213141516171819202122232425package com.sean.FactoryMethod.idcard;import java.util.ArrayList;import java.util.List;import com.sean.FactoryMethod.framework.Factory;import com.sean.FactoryMethod.framework.Product;public class IDCardFactory extends Factory &#123; private List owners = new ArrayList(); @Override protected Product createProduct(String owner) &#123; return new IDCard(owner); &#125; @Override protected void registerProduct(Product product) &#123; owners.add(((IDCard)product).getOwner()); &#125; public List getOwners()&#123; return owners; &#125;&#125;Main123456789101112131415161718package com.sean.FactoryMethod;import com.sean.FactoryMethod.framework.Factory;import com.sean.FactoryMethod.framework.Product;import com.sean.FactoryMethod.idcard.IDCardFactory;public class Main &#123; public static void main(String[] args) &#123; Factory factory=new IDCardFactory(); Product card1= factory.create("小明"); Product card2=factory.create("小红"); Product card3=factory.create("小刚"); card1.use(); card2.use(); card3.use(); &#125;&#125;要点工厂产生产品具体的工厂产生具体的产品这两者形成一一对应的关系。参照《图解设计模式》写这个只是为了加深自己对设计模式的理解，如不明白，可以看 《图解设计模式》。程序类图使用idea 生成的]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>FactoryMethod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flyweight模式]]></title>
    <url>%2F2021%2F01%2F29%2FFlyweight%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Flyweight 模式共享对象，避免浪费。类表名字说明BigChar表示”大型字符”类BigCharFactory表示生成和共用BigChar类的实例的类BigString表示多个BigChar组成的 “大型字符串” 的类Main测试程序行为的类程序类图代码BigChar类1234567891011121314151617181920212223242526272829303132333435import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;public class BigChar &#123; private char charname; private String fontdata; public BigChar(char charname)&#123; this.charname=charname; try &#123; BufferedReader reader=new BufferedReader(new FileReader("/home/sean/Documents/"+"big"+charname+".txt")); String line; StringBuffer buf=new StringBuffer(); while((line=reader.readLine())!=null)&#123; buf.append(line); buf.append("\n"); &#125; reader.close(); this.fontdata=buf.toString(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; this.fontdata=charname+"?"; e.printStackTrace(); &#125; &#125; public void print()&#123; System.out.print(fontdata); &#125;&#125;BigCharFactory类1234567891011121314151617181920212223242526package com.sean.Flyweight;import java.util.HashMap;public class BigCharFactory &#123; private HashMap pool=new HashMap(); //Singleton模式 private static BigCharFactory singleton=new BigCharFactory(); private BigCharFactory()&#123; &#125; //获取唯一实例 public static BigCharFactory getInstance()&#123; return singleton; &#125; //生成（共享)BigChar类实例 public synchronized BigChar getBigChar(char charname)&#123; BigChar bc=(BigChar) pool.get(""+charname); if(bc==null)&#123; bc=new BigChar(charname); pool.put(""+charname, bc); &#125; return bc; &#125;&#125;BigString类12345678910111213141516171819package com.sean.Flyweight;public class BigString &#123; private BigChar[] bigChars; public BigString(String string)&#123; bigChars=new BigChar[string.length()]; BigCharFactory factory=BigCharFactory.getInstance(); for(int i=0;i&lt;bigChars.length;i++)&#123; bigChars[i]=factory.getBigChar(string.charAt(i)); &#125; &#125; //显示 public void print()&#123; for(int i=0;i&lt;bigChars.length;i++)&#123; bigChars[i].print(); &#125; &#125; &#125;Main类123456789101112131415package com.sean.Flyweight;public class Main &#123; /** * @param args */ public static void main(String[] args) &#123; BigString bs=new BigString("10101"); bs.print(); &#125;&#125;要点Flyweight模式会对多个地方产生影响。Intrinsic: 应当被共享的信息Extrinsic: 不应当被共享的信息名字解释Instrinsic信息不依赖位置状况，可以共享Extrinsic信息依赖位置与状况，不能共享不要让被共享的实例被垃圾回收机器回收Flyweight优点：共享实例能减少对内存的使用，并且能提高运行的速度。参照《图解设计模式》写这个只是为了加深自己对设计模式的理解，如不明白，可以看 《图解设计模式》。程序类图使用idea 生成的]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>Flyweight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Iterator模式]]></title>
    <url>%2F2021%2F01%2F29%2FIterator%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Iterator模式一个一个遍历 迭代器类图codeAggregate12345package com.sean.Iterator;public interface Aggregate &#123; public abstract Iterator iterator();&#125;Iterator123456package com.sean.Iterator;public interface Iterator &#123; public abstract boolean hasNext(); public abstract Object next();&#125;Book1234567891011package com.sean.Iterator;public class Book &#123; private String name; public Book(String name)&#123; this.name=name; &#125; public String getName()&#123; return name; &#125;&#125;BookShelf1234567891011121314151617181920212223242526272829package com.sean.Iterator;import java.util.ArrayList;public class BookShelf implements Aggregate &#123; //private Book[] books; private ArrayList&lt;Book&gt; bookList = new ArrayList&lt;Book&gt;(); private int last=0;// public BookShelf(int maxsize)&#123;// this.books = new Book[maxsize];// &#125; public Book getBookAt(int index) &#123; return bookList.get(index); &#125; public void appendBook(Book book)&#123; bookList.add(book); last++; &#125; public int getLength()&#123; return last; &#125; public Iterator iterator() &#123; return new BookShelfIterator(this); &#125;&#125;BookShelfIterator12345678910111213141516171819202122232425262728package com.sean.Iterator;public class BookShelfIterator implements Iterator &#123; private BookShelf bookShelf; private int index; public BookShelfIterator(BookShelf bookShelf)&#123; this.bookShelf = bookShelf; this.index=0; &#125; public boolean hasNext() &#123; // TODO Auto-generated method stub if(index &lt; bookShelf.getLength())&#123; return true; &#125;else&#123; return false; &#125; &#125; public Object next() &#123; // TODO Auto-generated method stub Book book = bookShelf.getBookAt(index); index++; return book; &#125;&#125;Main123456789101112131415161718192021package com.sean.Iterator;public class Main &#123; public static void main(String[] args) &#123; //BookShelf bookShelf = new BookShelf(4); BookShelf bookShelf = new BookShelf(); bookShelf.appendBook(new Book("Around the World in 80 Days")); bookShelf.appendBook(new Book("Bible")); bookShelf.appendBook(new Book("Cinderella")); bookShelf.appendBook(new Book("Dady-Long-Legs")); bookShelf.appendBook(new Book("Gone with the wind!")); Iterator it = bookShelf.iterator(); while(it.hasNext())&#123; Book book = (Book) it.next(); System.out.println(book.getName()); &#125; &#125;&#125;参照《图解设计模式》写这个只是为了加深自己对设计模式的理解，如不明白，可以看 《图解设计模式》。程序类图使用idea 生成的]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello! Hexo]]></title>
    <url>%2F2021%2F01%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>officeWord</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adapter模式]]></title>
    <url>%2F2021%2F01%2F29%2FAdapter%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Adapter模式加个 “适配器” 以便复用Adapter模式也被称为Wrapper(包装器)模式。Adapter模式类适配器模式(使用继承的适配器)对象适配器模式(使用委托的适配器)类适配器模式(使用继承的适配器)类图codePrint123456package com.sean.Adapter.a;public interface Print &#123; public abstract void printWeak(); public abstract void printStrong();&#125;Banner1234567891011121314package com.sean.Adapter.a;public class Banner &#123; private String string; public Banner(String string)&#123; this.string=string; &#125; public void showWithParen()&#123; System.out.println("("+string+")"); &#125; public void showWithAster()&#123; System.out.println("*"+string+"*"); &#125;&#125;PrintBanner12345678910111213141516package com.sean.Adapter.a;public class PrintBanner extends Banner implements Print &#123; public PrintBanner(String string)&#123; super(string); &#125; public void printWeak() &#123; showWithParen(); &#125; public void printStrong() &#123; showWithAster(); &#125;&#125;Main123456789101112package com.sean.Adapter.a;public class Main &#123; public static void main(String[] args) &#123; Print print = new PrintBanner("Hello"); print.printWeak(); print.printStrong(); &#125;&#125;对象适配器模式(使用委托的适配器)类图codeBanner123456789101112131415package com.sean.Adapter.b;public class Banner &#123; private String string; public Banner(String string)&#123; this.string=string; &#125; public void showWithParen()&#123; System.out.println("("+string+")"); &#125; public void showWithAster()&#123; System.out.println("*"+string+"*"); &#125;&#125;Print123456package com.sean.Adapter.b;public abstract class Print &#123; public abstract void printWeak(); public abstract void printStrong();&#125;PrintBanner123456789101112131415161718192021package com.sean.Adapter.b;public class PrintBanner extends Print &#123; private Banner banner; public PrintBanner(String string)&#123; this.banner = new Banner(string); &#125; @Override public void printWeak() &#123; // TODO Auto-generated method stub banner.showWithParen(); &#125; @Override public void printStrong() &#123; // TODO Auto-generated method stub banner.showWithAster(); &#125;&#125;要点Adapter模式会对现有的类进行适配，生成行的类。版本的升级与兼容需要用到Adapter模式。适配！适配！就是给需要的类配对一个合适的插口。参照《图解设计模式》写这个只是为了加深自己对设计模式的理解，如不明白，可以看 《图解设计模式》。程序类图使用idea 生成的]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>Adapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Command模式]]></title>
    <url>%2F2021%2F01%2F29%2FCommand%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Command模式命令也是类类表包类名说明commandCommand表示命令的接口commandMacroCommand表示 由多条命令整合成的命令 的类drawerDrawCommand表示 绘制一个点的命令 的类drawerDrawable表示 绘制对象 的接口drawerDrawCanvas实现 绘制对象 的类无名Main测试程序行为的类类图粗略一点的详细一点codeCommand123456package com.sean.Command.command;public interface Command &#123; public abstract void execute(); &#125;MacroCommand1234567891011121314151617181920212223242526272829303132package com.sean.Command.command;import java.util.Iterator;import java.util.Stack;public class MacroCommand implements Command &#123; private Stack commands = new Stack(); public void execute() &#123; Iterator it=commands.iterator(); while(it.hasNext())&#123; ((Command)it.next()).execute(); &#125; &#125; public void append(Command command)&#123; if(command != this)&#123; commands.push(command); &#125; &#125; //删除最后一条命令 public void undo()&#123; if(!commands.empty())&#123; commands.pop(); &#125; &#125; //删除所有命令 public void clear()&#123; commands.clear(); &#125;&#125;Drawable12345package com.sean.Command.drawer;public interface Drawable &#123; public abstract void draw(int x,int y);&#125;DrawCanvas12345678910111213141516171819202122232425262728293031package com.sean.Command.drawer;import java.awt.Canvas;import java.awt.Color;import java.awt.Graphics;import com.sean.Command.command.MacroCommand;public class DrawCanvas extends Canvas implements Drawable &#123; //颜色 private Color color =Color.red; //绘制圆点半径 private int radius=6; //命令的历史记录 private MacroCommand history; public DrawCanvas(int width,int height,MacroCommand history)&#123; setSize(width, height); setBackground(Color.WHITE); this.history=history; &#125; //重新全部绘制 public void paint(Graphics g)&#123; history.execute(); &#125; public void draw(int x, int y) &#123; Graphics g=getGraphics(); g.setColor(color); g.fillOval(x-radius, y-radius, radius*2, radius*2); &#125;&#125;DrawCommand12345678910111213141516171819202122package com.sean.Command.drawer;import java.awt.Point;import com.sean.Command.command.Command;public class DrawCommand implements Command &#123; //绘制对象 protected Drawable drawable; //绘制位置 private Point position; public DrawCommand(Drawable drawable,Point position )&#123; this.drawable=drawable; this.position=position; &#125; public void execute() &#123; drawable.draw(position.x, position.y); &#125;&#125;Main12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.sean.Command;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.MouseEvent;import java.awt.event.MouseMotionListener;import java.awt.event.WindowEvent;import java.awt.event.WindowListener;import javax.swing.Box;import javax.swing.BoxLayout;import javax.swing.JButton;import javax.swing.JFrame;import com.sean.Command.command.Command;import com.sean.Command.command.MacroCommand;import com.sean.Command.drawer.DrawCanvas;import com.sean.Command.drawer.DrawCommand;public class Main extends JFrame implements ActionListener, MouseMotionListener, WindowListener &#123; //绘制的历史记录 private MacroCommand history=new MacroCommand(); //绘制区域 private DrawCanvas canvas=new DrawCanvas(400,400,history); //删除按钮 private JButton clearButton=new JButton("clear"); //构造函数 public Main(String title)&#123; super(title); this.addWindowListener(this); canvas.addMouseMotionListener(this); clearButton.addActionListener(this); Box buttonBox=new Box(BoxLayout.X_AXIS); buttonBox.add(clearButton); Box mainBox=new Box(BoxLayout.Y_AXIS); mainBox.add(buttonBox); mainBox.add(canvas); getContentPane().add(mainBox); pack(); show(); &#125; public void windowOpened(WindowEvent e) &#123; &#125; public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; public void windowClosed(WindowEvent e) &#123; &#125; public void windowIconified(WindowEvent e) &#123; &#125; public void windowDeiconified(WindowEvent e) &#123; &#125; public void windowActivated(WindowEvent e) &#123; &#125; public void windowDeactivated(WindowEvent e) &#123; &#125; public void mouseDragged(MouseEvent e) &#123; Command command=new DrawCommand(canvas,e.getPoint()); history.append(command); command.execute(); &#125; public void mouseMoved(MouseEvent e) &#123; &#125; public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==clearButton)&#123; history.clear(); canvas.repaint(); &#125; &#125; public static void main(String[] args)&#123; new Main("Command Pattern"); &#125;&#125;参照《图解设计模式》写这个只是为了加深自己对设计模式的理解，如不明白，可以看 《图解设计模式》。程序类图使用idea 生成的]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>Command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Facade模式]]></title>
    <url>%2F2021%2F01%2F29%2FFacade%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[#Facade模式简单窗口&ensp; 使用Facode模式可以为相互关联在一起的错中复杂的类整理出高层的接口。其中的Facade角色可以让系统对外只有一个简单的接口。演示程序类图代码Database类12345678910111213141516171819202122232425package com.sean.Facade.pagemaker;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.util.Properties;public class Database &#123; private Database()&#123; //防止外部new出Database对象，所以声明为private &#125; public static Properties getProperties(String dbname)&#123; String filename=dbname+".txt"; Properties prop=new Properties(); try &#123; prop.load(new FileInputStream("/home/sean/Documents/"+filename)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return prop; &#125;&#125;HtmlWriter类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.sean.Facade.pagemaker;import java.io.IOException;import java.io.Writer;public class HtmlWriter &#123; private Writer writer; public HtmlWriter(Writer writer)&#123; this.writer=writer; &#125; public void title(String title)&#123; //输出标题 try &#123; writer.write("&lt;html&gt;"); writer.write("&lt;head&gt;"); writer.write("&lt;title&gt;"+title+"&lt;/title&gt;"); writer.write("&lt;/head&gt;"); writer.write("&lt;body&gt;\n"); writer.write("&lt;h1&gt;"+title+"&lt;/h1&gt;"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public void paragraph(String msg)&#123; //输出段落 try &#123; writer.write("&lt;p&gt;"+msg+"&lt;/p&gt;"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public void link(String href,String caption)&#123; //输出超链接 paragraph("&lt;a href=\"" +href +"\"&gt;"+caption+"&lt;/a&gt;"); &#125; public void mailto(String mailaddr,String username)&#123; //输出邮件地址 link("mailto:"+mailaddr,username); &#125; public void close()&#123; //结束输出html try &#123; writer.write("&lt;/body&gt;"); writer.write("&lt;/html&gt;\n"); writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;PageMaker类123456789101112131415161718192021222324252627package com.sean.Facade.pagemaker;import java.io.FileWriter;import java.io.IOException;import java.util.Properties;public class PageMaker &#123; private PageMaker()&#123; //防止外部new出PageMaker实例，所以声明为private方法 &#125; public static void makeWelcomePage(String mailaddr,String filename)&#123; try &#123; Properties mailprop=Database.getProperties("maildata"); String username=mailprop.getProperty(mailaddr); HtmlWriter writer=new HtmlWriter(new FileWriter("/home/sean/Documents/"+filename)); writer.title("Welcome to "+username+"'s page!"); writer.paragraph(username+"欢迎到来"+username+"的主页。"); writer.paragraph("等你的邮件喔！"); writer.mailto(mailaddr, username); writer.close(); System.out.println(filename+"is created for "+mailaddr +" ("+username+")"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;Main类123456789101112131415package com.sean.Facade;import com.sean.Facade.pagemaker.PageMaker;public class Main &#123; /** * @param args */ public static void main(String[] args) &#123; PageMaker.makeWelcomePage("seanchristspc@gmail.com", "welcome.html"); &#125;&#125;要点Facade(窗口)Facade角色向系统外部提供高层接口。在实例程序中由PageMaker扮演此角色。构成系统的许多其他角色这些角色各自完成自己的工作，他们并不知道Facade角色。Facade角色调用其他角色进行工作，但是其他角色不会调用Facade角色。代码中 Database和HtmlWriter扮演其他角色。ClientClient角色负责调用Facade角色个人理解Facade模式就是把复杂的系统变看起来简单。所谓看起来简单就是指在编写代码的时候还是挺复杂的，只是在使用某个功能是对外的接口比较少而且明确。该模式还是挺好理解的，代码也不复杂。参照图解设计模式写这个只是为了加深自己对设计模式的理解，如不明白，可以看 《图解设计模式》。程序类图使用idea 生成的]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>Facade</tag>
      </tags>
  </entry>
</search>
